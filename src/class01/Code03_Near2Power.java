package class01;


/**
 * 给定一个非负整数num，如何不用循环语句，返回>=num，并且离num最近的，2的某次方
 *
 * 思路: 没懂，待看视频解析
 * 		 将数的二进制形式，全部换算成最高位及其之后全部为1的情况，然后再加1
*
 *我们知道，一个非负整数要么是0，要么它的二进制表示里一定至少有一个1。所以我们要做的就是把最高位的1之后的所有bit全变为1，
 *然后再加1就得到结果了。我们先把 n 不带符号右移1位，这样我们得到一个最高位的1比n低1位的整数，姑且称它为m。
 *然后我们再把m和n按位或一下，结果是什么不重要，重要的是它一定有两位是1，而这两位是n的最高位的1那一位和m的最高位的1那一位
 *（也就是n最高位的1的后一位），并且n原先开头有多少个0，这一步的结果开头还是多少个0。也就是说，这一步的结果在开头若干个0之后，
 *有两位连续的1。然后我们利用这两位连续的1，制造4位连续的1，做法和上面一样，只不过右移2位。有了4位连续的1，我们就能制造8位连续的1，
 *只要把右移改成4位就行。以此类推，直到我们能确保在开头的一串0之后全是1为止。最后一次右移是该语言的整数类型的bit数的一半。
 *那为什么一开始要减1呢？因为输入的整数num本身可能就已经是2的整数次方了，这时候应该返回num本身，而不是它的2倍。
*
* 作者：Aetherus
* 链接：https://www.zhihu.com/question/457611128/answer/1866124096
* 来源：知乎
* 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
 */
public class Code03_Near2Power {

	// 已知n是正数
	// 返回大于等于，且最接近n的，2的某次方的值
	public static final int tableSizeFor(int n) {
		//先n--是因为防止n这个数本身就是2的某次方的情况
		n--;
		n |= n >>> 1;   // 先用第一个1 和第二位做或运算，这样第一位和第二位就都是1了
		n |= n >>> 2;	// 同理，用第一和二个1 和 第三第四位做或运行，这样第三和第四就变成1了
		n |= n >>> 4;
		n |= n >>> 8;
		n |= n >>> 16;  // 因为int整数是32位，所以用一半的1，和另一半做或操作就是了
		return (n < 0) ? 1 : n + 1;
	}

	public static void main(String[] args) {
		int cap = 7;
		System.out.println(tableSizeFor(cap));
	}

}
